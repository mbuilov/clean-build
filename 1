Предисловие.

clean-build - простая, быстрая, нерекурсивная, шаблонная, платформонезависимая система сборки, полагающая только на возможности интерпретатора Gnu Make и основанная на следующих принципах:

1) Декларативное описание сценария сборки.

  Для типовых сценариев, в целевом Makefile достаточно указать шаблон и параметры для его инициализации.
  Также есть возможность написания произвольных правил сборки, используя возможности Gnu Make.

2) Нерекурсивность исполнения правил сборки.

  Порядок сборки целей определяется только указанием их зависимостей, а не порядком включения целевых Makefile'ов (в отличие от рекурсивных систем сборки).
  Сначала происходит зачитывание и разбор всех Makefile'ов проекта, затем построение единого дерева зависимостей целей, затем (параллельное) выполнение целей.

  Единое дерево зависимостей позволяет максимально распараллелить выполнение целей проекта, утилизируя все доступные ресурсы сборочной машины.

3) Использование только нативных утилит сборочной платформы.

  Система сборки минималистична, полагается только на возможности Gnu Make и, опционально, sed.
  Данные утилиты доступны в нативном виде для всех поддерживаемых платформ: Windows, Linux, Solaris.


Основные характеристики.

........


Установка.

  Достаточно скопировать clean-build в директорию без пробелов в пути, например в C:\tools или /usr/home/user.


Запуск сборки.

  Сборка запускается обычным вызовом интерпретатора Gnu Make, например:

  1) make distclean

  2) make -j4

  3) make -f dir/Makefile check
     или
     make -C dir check

  4) вызов из bash (например под cygwin) с заданием параметров сборки:

    make MTOP=/cygdrive/c/User/clean-build OS=LINUX CPU=x86_64 COMPILER_TYPE=GCC6 NO_STACK_PROTECTOR=1 NO_SANITIZE=1 NO_COVERAGE=1 DLL_PREFIX= DLL_SUFFIX=.dll MEMSTACK_INCLUDE=/cygdrive/c/User/memstack MEMSTACK_LIBDIR='/cygdrive/c/User/memstack/lib/$(TARGET_TRIPLET)' CMN_HEADERS_INCLUDE=/cygdrive/c/User/cmn_headers GTPARSER_INCLUDE=/cygdrive/c/User/gtparser GTPARSER_LIBDIR='/cygdrive/c/User/gtparser/lib/$(TARGET_TRIPLET)'

  5) вызов из командного итерпретатора cmd.exe с заданием параметров сборки:

    C:\tools\gnumake-4.2.1-x64.exe MTOP=c:\User\clean-build SED=c:\tools\sed-4.4-x64.exe OS=WINXX CPU=x86 OSVARIANT=WIN7 VS="d:\Program Files (x86)\Microsoft Visual Studio\2017\Community\VC\Tools\MSVC\14.10.25017" WDK="c:\Program Files (x86)\Windows Kits\10" WDK_TARGET="10.0.14393.0" MEMSTACK_INCLUDE=C:\User\memstack MEMSTACK_LIBDIR=C:\User\memstack\lib\$(TARGET_TRIPLET) MEMSTACK_DLLDIR=C:\User\memstack\bin\$(TARGET_TRIPLET) CMN_HEADERS_INCLUDE=C:\User\cmn_headers GTPARSER_INCLUDE=C:\User\gtparser GTPARSER_LIBDIR=C:\User\gtparser\lib\$(TARGET_TRIPLET)


Примеры построения правил сборки.


  1) Сборка статической библиотеки.

  ################################
  include $(MTOP)/c.mk
  LIB     := my_lib
  SRC     := my_source1.c my_source2.c
  INCLUDE := my_include1 my_include2
  $(DEFINE_TARGETS)
  ################################

  Первой строкой указывается включение файла $(MTOP)/c.mk - добавление шаблонов сборки целей на языках C, C++

  Далее указываются параметры шаблонов:

  LIB     - выбирает шаблон сборки статической библиотеки и задаёт её имя (без расширения)
  SRC     - список файлов исходных текстов библиотеки
  INCLUDE - список дополнительных директорий для поиска #include-файлов
  $(DEFINE_TARGETS) - раскрывает макрос исполнения выбранных шаблонов сборки.


  2) Создание сборочной утилиты.

  Сборочная улитита может быть запущена во время сборки, например для генерации исходных текстов.
  В случае кросс-компиляции, архитектура сборочной улититы соответствует архитектуре сборочной машины и может отличаться от архитектуры собираемых исполняемых файлов.

  ################################
  TOOL_MODE := 1
  include $(MTOP)/c.mk
  EXE := my_tool
  SRC := my_tool_source.c
  $(DEFINE_TARGETS)
  ################################

  Выставление переменной TOOL_MODE в непустое значение (которое будет очищено в $(DEFINE_TARGETS)) настраивает шаблоны сборки на создание утилит сборки.
  Тем самым, следующее включение $(MTOP)/c.mk переопределит пути системы сборки для создаваемых файлов на пути для утилит сборки.

  Параметры шаблонов:

  EXE       - выбирает шаблон сборки исполняемого файла и задаёт его имя (без расширения)
  SRC       - список файлов исходных текстов исполняемого файла
  $(DEFINE_TARGETS) - раскрывает макрос исполнения заданных шаблонов сборки.


  3) Генерация произвольных файлов.

  Для генерации произвольных файлов нужно определить правила их генерации и добавить сгенерённые файлы в сборку чезез вызов макроса ADD_GENERATED.

  ################################
  include $(MTOP)/defs.mk
  MY_GENERATED := $(GEN_DIR)/my_dir/my_file.txt
  $(call ADD_GENERATED,$(MY_GENERATED))
  $(MY_GENERATED): MY_OPTIONS := my_options
  $(MY_GENERATED): $(call GET_TOOL,my_tool) $(VPREFIX)my_source.txt
  	$(call ospath,$<) $(MY_OPTIONS) -o $(call ospath,$(word 2,$^))
  $(DEFINE_TARGETS)
  ################################

  Разберём пример построчно.

  1) Включение $(MTOP)/defs.mk добавляет определение стандартных функций и определений.
    Вообще, включение любого набора шаблонов clean-build (например упоминаемый ранее $(MTOP)/c.mk) также включает $(MTOP)/defs.mk.

  2) строка
   MY_GENERATED := $(GEN_DIR)/my_dir/my_file.txt
   задаёт имя генерируемого файла.
   Имя переменной MY_GENERATED выбрано произвольно, однако возможны коллизии с предопределёнными именами clean-build.
   Найти коллизии в именах переменных поможет запуск "make C=1" (режим check makefiles).
   GEN_DIR - путь к директории для сгенерённых в процессе сборки файлов.
   Вообще, система сбоки позволяет генерить файлы только в директориях $(GEN_DIR), $(LIB_DIR), $(BIN_DIR) или $(OBJ_DIR).

  3) вызов
   $(call ADD_GENERATED,$(MY_GENERATED))
   добавляет генерируемые файлы в сборку:
   - директория $(GET_DIR)/my_dir будет создана автоматически перед вызовом правила генерации файлов,
   - при выполнении "make clean" сгенерённые файлы будут удалены.

  4) строка
   $(MY_GENERATED): MY_OPTIONS := my_options
   определяет target-specific переменную MY_OPTIONS со значением my_options.
   В системе сборки clean-build важно использовать по-возможности тоько target-specific переменные - из-за нерекурсивности системы сборки.
   После того, как очередной Makefile разобран и определены правила сборки целей, может быть включён и разобран следующий Makefile, который может переопределить переменные из первого Makefile.
   Поэтому переменные нужно привязывать к цели сборки - цели сборки всегда уникальны, что контролируется самим Gnu Make.

  5) следующие две строки определяют правило сборки файла $(MY_GENERATED)
   $(MY_GENERATED): $(call GET_TOOL,my_tool) $(VPREFIX)my_source.txt
  	$(call ospath,$<) $(MY_OPTIONS) -o $(call ospath,$(word 2,$^))

  а) Первая строка задаёт зависимости $(MY_GENERATED) от утилиты сборки и файла my_source.txt.

   Раскрытие параметризованного макроса GET_TOOL через $(call GET_TOOL,my_tool) даёт путь к утилите сборки my_tool (пример создания my_tool приведён выше).
   Указание $(VPREFIX)my_source.txt задаёт зависимость генерируемого файла от my_source.txt, расположенного в той же директории, что и Makefile.

   В $(VPREFIX) содержится относительный путь от директории, в которой запущен make к директории, в которой расположен целевой Makefile.
   В приведённых выше примерах сборки статической библиотеки и утилиты $(VPREFIX) не указывался перед именами исходных файлов - $(VPREFIX) добавляется автоматически, если путь не абсолютный (указанный относительно $(TOP)).
   Здесь же задаётся произвольное правило сборки - все зависимости нужно указывать явно.

  б) Вторая строка (начинающаяся с символа табуляции) определят метод генерации файла.

   $< - автоматическая переменная - имя первой зависимости цели, в данном случае это путь, возвращаемый $(call GET_TOOL,my_tool).
   Вызовом $(call ospath,$<) путь к утилите my_tool преобразуется в путь к фалу, характерный для операционной системы сборочной машины (например преобразуется C:/a/b -> C:\a\b).

   $(MY_OPTIONS) - раскрывается в my_options.

   $^ - автоматическая переменная - список всех зависимостей цели в порядке их перечисления.
   $(word 2,$^) - имя второй зависимости цели, в данном случае это $(VPREFIX)my_source.txt.

   Замечание:
    VPREFIX не была объявлена как target-specific переменная, поэтому нельзя использовать выражение $(VPREFIX)my_source.txt в теле правила - VPREFIX может быть изменена в следующих включенных Makefile'ах после задания данного правила построения цели.

   $(call ospath,$(word 2,$^)) - преобразование пути к my_source.txt в путь, характерный для операционной системы сборочной машины.

  6) $(DEFINE_TARGETS) - раскрывает макрос исполнения заданных шаблонов сборки.
   В данном случае, т.к. никаких предопределённых шаблонов сборки указано не было, то $(DEFINE_TARGETS) не делает ничего, кроме включения завершающего $(MTOP)/all.mk, если текущий Makefile был обработан последним.
   Завершающий $(MTOP)/all.mk содержит определение цели по-умолчанию all, для выполнения которой нужно выполнить все определённые правила.

   Замечание.
     Вместе с заданием правила генерации произвольного файла можно было задать шаблон сборки, скажем библиотеки (включением $(MTOP)/c.mk вместо $(MTOP)/defs.mk), тогда $(DEFINE_TARGETS) также приведёт к сборке библиотеки.


  4) Генерация нескольких файлов из одного исходного файла.

  В Gnu Make нет специальных средств для решения проблемы с генерацией нескольких целей из одних и тех же исходных файлов одним вызовом - правило построения цели в Gnu Make предполагает, что целевой файл всегда один.
  А нужно, чтобы правило генерации нескольких целей выполнялось единожды при необходимости генерации любой из целей.

  Для решения этой проблемы, в clean-build определён макрос MULTI_TARGET.

  ################################
  include $(MTOP)/defs.mk
  MY_OPTIONS := my_options
  MY_GENERATED := $(addprefix $(GEN_DIR)/my_dir/,my_file1.txt my_file2.txt)
  $(call MULTI_TARGET,$(MY_GENERATED),$(call GET_TOOL,my_tool) $(VPREFIX)my_source.txt,$$(call \
    ospath,$$<) $(MY_OPTIONS) -o $(VPREFIX)my_source.txt)
  $(DEFINE_TARGETS)
  ################################

  Макрос MULTI_TARGET, определённый в $(MTOP)/defs.mk, принимает 3 аргумента:
  1) список генерируемых файлов              - $(MY_GENERATED)
  2) список зависимостей генерируемых файлов - $(call GET_TOOL,my_tool) $(VPREFIX)my_source.txt
  3) правило генерации файлов                - $$(call ospath,$$<) $(MY_OPTIONS) -o $(VPREFIX)my_source.txt

  Перед вызовом макроса MULTI_TARGET, вычисляется каждый из передаваемых ему аргументов.
  Так как правило генерации файлов, передаваемое 3-им аргументом, будет раскрыто дважды - первый раз во время вызова MULTI_TARGET, второй - во время выполнения правила, то вызов $(ospath) и переменной $< экранирован двойным $$.

  Значение переменной VPREFIX необходимо использовать сразу, до включения следующего Makefile, в котором VPREFIX может быть изменена.
  Или можно сохранить $(VPREFIX) в target-specific переменной, чтобы использовать это значение во время выполнения правила.

  Переменная MY_OPTIONS не объявлена как target-specific, в отличие от предыдущего примера, т.к. используется сразу, в момент определения правила сборки, а не в момент выполнения правила.


  5) Объединение Makefile'ов в группу.
  
  ################################
  MDEPS := my_gen.mk
  TO_MAKE := tool1.mk lib1/my_lib.mk $(TOP)/dir1/dir2/my_exe_dir
  include $(MTOP)/parallel.mk
  ################################

  Группа Makefile'ов указывается в переменной TO_MAKE, значение которой интерпретируется в подключаемом $(MTOP)/parallel.mk.

  Makefile'ы указываются как имена файлов с расширением .mk или директорий, путь к которым может быть либо относительным от текущего Makefile, либо абсолютным - от корня проекта в переменной TOP.
  Если элемент списка $(TO_MAKE) не заканчивается на .mk, то предполагается, что это директория, в которой ищется файл с именем Makefile.

  В переменной MDEPS можно указать список Makefile'ов, от которых зависят цели текущего Makefile (группы Makefile'ов, как в данном примере).
  Правила указания Makefile'ов в переменной MDEPS те же, что и для переменной TO_MAKE.

  Цели, указанные в Makefile'ах tool1.mk, lib1/my_lib.mk и $(TOP)/dir1/dir2/my_exe_dir/Makefile будут выполнены только после того, как будут выполнены цели Makefile'ов из $(MDEPS).

  Если Makefile из $(MDEPS) не был подключён к сборке в процессе определения целей, то он игнорируется.
  Таким образом, возможно выполнение (пере-)сборки модуля в его поддиректории, без необходимости пересобирать внешние зависимости, как в следующем примере:

  top_dir/Makefile:
  TO_MAKE := gen module
  include $(MTOP)/parallel.mk

  top_dir/module/Makefile:
  MDEPS := ../gen
  ....
  $(DEFINE_TARGETS)


  6) Собираем что-то уникальное, например выполняем тесты.
  
  ################################
  include $(MTOP)/defs.mk
  MDEPS := build_tests.mk
  TESTS := rb_test c_base64_test
  $(call ADD_GENERATED,$(addprefix $(GEN_DIR)/tests/,$(addsuffix .tsmt,$(TESTS))))
  define TEST_RULE
  $(newline)
  $(GEN_DIR)/tests/$t.tsmt: $(BIN_DIR)/$t$(EXE_SUFFIX)
  	$$(call SUP,TEST,$$<)$$< > $(GEN_DIR)/tests/$t.out
  	$(if $(VERBOSE),,@)$$(call TOUCH,$$@)
  endef
  $(eval $(foreach t,$(TESTS),$(TEST_RULE)))
  $(DEFINE_TARGETS)
  ################################
  
  Здесь:

  1) MDEPS := build_tests.mk
   Задаёт что цели, указанные в build_tests.mk (например сборка тестируемых исполняемых файлов) должны быть выполнены до целей текущего Makefile.

  2) TESTS := rb_test c_base64_test
   Список тестируемых исполняемых файлов.

  3) $(call ADD_GENERATED,$(addprefix $(GEN_DIR)/tests/,$(addsuffix .tsmt,$(TESTS))))
   В результате запуска тестов будут сгенерены файлы rb_test.tsmt и c_base64_test.tsmt в директории $(GEN_DIR)/tests.

  4) define TEST_RULE
   Определяем шаблон запуска теста.

  5) $(newline)
   Тело определяемого шаблона TEST_RULE начинается со строки, следующей за "define TEST_RULE".
   Пусть первым символом шаблона будет перевод строки (переменная newline определена в $(MTOP)/defs.mk).
   Это позволит начинать определение очередного правила с новой строки - при раскрытии шаблона в цикле foreach.

  6) шаблонное правило c параметром шаблона $t:
    $(GEN_DIR)/tests/$t.tsmt: $(BIN_DIR)/$t$(EXE_SUFFIX)
    	$$(call SUP,TEST,$$<)$$< > $(GEN_DIR)/tests/$t.out
    	$(if $(VERBOSE),,@)$$(call TOUCH,$$@)

    определяет, что результат теста в директории $(GEN_DIR)/tests будет зависеть от даты создания тестируемого исполняемого файла в директории $(BIN_DIR).

	Для выполнения теста будет вызван исполняемый файл $(BIN_DIR)/$t$(EXE_SUFFIX) (указываемый через автоматическую перемсенную $$<), а stdout этого вызова будет перенаправлен в $(GEN_DIR)/tests/$t.out.
	Вызов $$(call SUP,TEST,$$<) служит для информационной печати на экране выполняемой операции или команды (если make вызван с параметром V=1).
    $$(call TOUCH,$$@) - вторая команда правила генерации файла $(GEN_DIR)/tests/$t.tsmt (указываемого через автоматическую перемсенную $$@).
	Макрос TOUCH определён в $(MTOP)/defs.mk через подключение файла определений, специфичного для текущей сборочной платформы.
	Конструкция $(if $(VERBOSE),,@) - даёт пустое значение в "verbose" режиме (если make вызван с параметром V=1) и @ в обычном режиме.
	А символ @ перед командой отключает показ make'ом вызываемой команды.

	Соответственно, в обычном режиме, при выполнении правила шаблона make напечатает что-то вроде:
	"TEST   /home/user/procject/bin/LINUX-x86_64-x86_64-DEBUG/rb_test"

	А в verbose-режиме:
	/home/user/procject/bin/LINUX-x86_64-x86_64-DEBUG/rb_test > /home/user/procject/gen/LINUX-x86_64-x86_64-DEBUG/rb_test.out
	touch /home/user/procject/gen/LINUX-x86_64-x86_64-DEBUG/rb_test.tsmt

	Замечания:
	 1) команды правила должны начинаться с символа табуляции,
	 2) тест правил будет интерпретирован дважды - один раз при раскрытии шаблона, второй - в момент выполнения правил. Поэтому раскрытие некоторых макросов в правилах отложено до второго раза - путём экранирования символа $ двойным $$.

  7) endef
   Конец шаблона TEST_RULE.
   Замечание: тело шаблона не включает перевод строки перед endef.

  8) $(eval $(foreach t,$(TESTS),$(TEST_RULE)))
   Для каждого $t из списка $(TESTS) раскрывается шаблон TEST_RULE, затем полученный список правил интерпретируется функцией eval как если бы эти правила были заданы в тексте Makefile.

  Небольшое замечание:
   функция foreach разделяет результаты раскрытия шаблона TEST_RULE пробелами, поэтому в конце последней строки шаблона будет добавлен пробел.
   А из-за того, что первым символом шаблона является $(newline), функции eval для интерпретации на вход поступят правила, начинающиеся с новой строки.

  9) $(DEFINE_TARGETS) - раскрывает макрос исполнения заданных шаблонов сборки.
   В данном случае, т.к. никаких предопределённых шаблонов сборки указано не было, то $(DEFINE_TARGETS) не делает ничего, кроме включения завершающего $(MTOP)/all.mk, если текущий Makefile был обработан последним.








   отделять пустой строкой в дальнейшем 


   
   что для выполения тестов должны быть собраны тестируемые испорлняемые файлы.

   Возможно, более корректным было бы указание зависимост


  
  определяется шаблон TEST_RULE - для построения правил выполнения тестов, подключённых к системе сборки вызовом ADD_GENERATED.




GEN_DIR       - путь к директории для сгенерённых файлов (который берёт начало от $(XTOP));
ADD_GENERATED - функция для добавления сгенерённых файлов к сборке - директория $(GET_DIR)/my_dir будет создана автоматически, при выполнении make clean сгенерённые файлы будут удалены;
VPREFIX       - относительный путь от текущей директории до директории, в которой находится целевой Makefile. Таким образом, путь к my_source.txt может быть указан относительно целевого Makefile;
GET_TOOL      - функция получения полного пути к утилите, ранее добавленной в сборку;
ospath        - функция преобразования путей с обратными слешами в пути, специфичные для сборочной платформы (c:/a/b -> c:\a\v\b);

Также в данном Makefile используются:

MY_GENERATED  - произвольно выбранное имя переменной, не обязательно уникальное - система сборки поддерживает режим проверки переопределения зарезервированных имён;
$<            - автоматическая переменная - имя первой зависимости цели, в данном случае это $(call GET_TOOL,my_tool);
$^            - автоматическая переменная - список всех зависимостей цели в порядке их перечисления;
$(word 2,$^)  - имя второй зависимости цели, в данном случае это $(VPREFIX)my_source.txt (замечание: VPREFIX не была объявлена как target-specific переменная, поэтому нельзя использовать выражение $(VPREFIX)my_source.txt в теле правила - VPREFIX может быть изменена после описания правила построения цели но до выполнения этого правила);
MY_OPTIONS    - объявление target-specific переменной - последующие переопределения переменной my_options никак не скажутся на значение этой переменной в правиле генерации $(MY_GENERATED);
$(DEFINE_TARGETS) - стандартный макрос применения шаблонов правил для сборки указанной цели (в данном случае - )





  А при создании утилит сборки будет использован компилятор $(TCC) - для исходных текстов на языке C, или $(TCXX) - для исходных текстов на языке C++.
  Компилятор утилит $(TCC), используемый в режиме TOOL_MODE может отличаться от компилятора языка C обычного режима $(СС). В этом случае будет выполнена кросс-компиляция - когда собираемые в обычном режиме исполняемые файлы могут не работать на сборочной платформе, в отличие от собираемых в режиме TOOL_MODE утилит сборки.




  
  правил для сборки указанной цели (в данном случае - библиотеки)





  Однако, если нужно задать порядок выполнения Makefile'ов как в рекурсивной системе сборки, зависимость между Makefile'ами нужно указывать явно - через переменную MDEPS. Этот же подход используется, например, при построении исполняемого файла - необходимые библиотеки указываются как зависимости от целевого исполняемого файла.
 Система сборки работает в 2 этапа:
- сначала определяются все правила для выполнения всех целей,
- затем эти правила выполняются параллельно с учётом зависимостей между целями.
 Для удобства, обычно, структура вложенности Makefile'ов соответствует вложенности директорий проекта - при выполнении сборки в какой-либо директории проекта зачитываются все Makefile'ы из этой директории и её под-директорий.

2) Использование target-specific переменных (переменных, связанных с целью).
 Так как этапы построения правил сборки целей и выполнения этих правил разделены, то нельзя использовать переменные этапа построения правил в самих правилах сборки.
 Например, при построении правила сборки библиотеки в переменной LIB задаётся имя собираемой библиотеки.
 После того, как это правило построено, может быть задано построение правила сборки другой библиотеки, с другим значением переменной LIB.
 Если использовать переменную LIB при выполнении правила сборки первой библиотеки - LIB уже содержит имя второй библиотеки.
 Чтобы запомнить имя библиотеки для его использования при выполнении правила сборки, необходимо связать переменную LIB с собираемой библиотекой - задать target-specific переменную.
 Значение этой переменной будет связано с целью правила сборки - для разных целей будут разные значения target-specific переменной.
 Это позволяет использовать один и тот же шаблон правил для построения правил сборки разных библиокек.

3) Отсутствие правил сборки целей по-образцу (pattern rules).
 Вместо этого используются шаблоны построения явных правил сборки.
 Во-первых, это проще в отладке - всегда можно определённо сказать, какое правило сборки применяются для данной цели,
 во-вторых, достаточно использования target-specific переменных, нет необходимости в pattern-specific переменных,
 в-третьих, использование pattern-specific переменных может снижать производительность интерпретации Makefile'ов (http://electric-cloud.com/blog/2009/04/makefile-performance-pattern-specific-variables/)

-----------------------------------------------------------------

Описание файлов.

1) defs.mk        - файл общих определений, доступных в любом целевом Makefile, включает в себя следующие файлы:
  a) top.mk       - проверка корректности значений переменных TOP (корневая директория проекта) и XTOP (корневая директория создаваемых в процессе сбоки файлов)
  b) functions.mk - вспомогательные функции и определения
  c) $(TOP)/make/project.mk - файл дополнительных определений проекта
                              (включается, если есть - настройки проекта также можно задать через переменные окружения)
  d) $(MTOP)/$(OS)/tools.mk - утилиты сборочной платформы OS (содание директорий, копирования файлов и т.д.), MTOP - путь к директории clean-build

2) c.mk           - общие шаблоны для сборки целей на языках C или C++, включает в себя следующие файлы:
  a) defs.mk      - описан выше
  b) include $(MTOP)/$(OS)/c.mk - утилиты и дополнительные шаблоны для сборки целей на языках C или C++ (компиляторы) для платформы OS

3) java.mk        - общие шаблоны для сборки целей на языках JAVA и SCALA, включает в себя следующие файлы:
  a) defs.mk      - описан выше
  b) include $(MTOP)/$(OS)/java.mk - утилиты и дополнительные шаблоны для сборки целей на языке JAVA для платформы OS

4) all.mk         - определяет цель сборки по умолчанию (all) и цель очистки результатов сборки (clean)

5) parallel.mk    - выполняет "параллельно" список целевых Makefile'ов, служит для обработки списка целевых Makefile'ов

Для целевой платформы WINDOWS существует ещё 3 дополнительных файла:

6) $(MTOP)/WINXX/auto_c.mk - автонастройка системы сборки под WINDOWS
7) $(MTOP)/WINXX/cres.mk   - шаблон для создания ресурсного файла с описанием версии продукта,
                             подключаемого в каждый исполняемый модуль или динамическую библиотеку.
8) $(MTOP)/WINXX/wix.mk    - шаблоны для сборки инсталлятора WiX (Windows Installer XML)

Замечание: файлы defs.mk, c.mk, java.mk, parallel.mk и WINXX/wix.mk разделены на 2 части - для исключения повторного разбора уже разобранных определений. Например, defs.mk будет долго обрабатываться системой сборки (из-за включения _defs.mk) только при его первом включении в целевой Makefile, при последующих включениях defs.mk в другие целевые Makefile'ы, _defs.mk включаться и обрабатываться уже не будет.

Вспомогательные файлы:

make.bat и make.sh - автоматическое определение значения переменной TOP (корня проекта) - через поиск файла .top в родительских директориях текущей директории.

Определять TOP автоматически бывает удобно в случае наличия нескольких директорий с разными версиями проекта.
Если TOP выставляется вручную, то перейдя в директорию с другой версией проекта можно забыть изменить значение TOP и, соответственно, выполнить сборку проекта не из текущей директории.

-----------------------------------------------------------------

Типовые примеры построения правил сборки.

1) Сборка статической библиотеки.

################################
include $(MTOP)/c.mk
LIB     := my_lib
SRC     := my_source1.c my_source2.c
INCLUDE := my_include1 my_include2
$(DEFINE_TARGETS)
################################

включение $(MTOP)/c.mk добавляет определение шаблонов сборки целей на языках C, C++

LIB     - задаёт имя собираемой библиотеки
SRC     - список файлов исходных текстов библиотеки
INCLUDE - список дополнительных директорий для поиска #include-файлов
$(DEFINE_TARGETS) - стандартный макрос применения шаблонов правил для сборки указанной цели (в данном случае - библиотеки)

Помимо обязательных переменных LIB, SRC и необязательной INCLUDE, можно также задать:

- DEFINES - список #define-определений.
 По-умолчанию, этот список содержит:
  PREDEFINES - список глобальных #define-определений из файла проекта $(TOP)/make/project.mk,
  OS_PREDEFINES - список глобальных #define-определений целевой операционной системы (например _WIN32_WINNT=0x0501) - из $(MTOP)/$(OS)/c.mk.
 Обычно в целевом Makefile список DEFINES дополняется (через DEFINES += my_defs), но можно и исключить глобальные определения из этого списка (через DEFINES := my_defs)

- CMNINCLUDE - глобальный список путей поиска #include-файлов проекта.
 По-умолчанию, этот список равен DEFINCLUDE - списку путей из файла настроек проекта $(TOP)/make/project.mk.
 Чтобы исключить глобальные пути поиска #include-файлов проекта в целевом Makefile нужно очистить CMNINCLUDE присвоив этой переменной пустое значение (CMNINCLUDE:=)

- INCLUDE - список путей поиска #include-файлов.
 Присвоение значения этой переменной в целевом Makefile дополняет пути поиска, по-умолчанию INCLUDE имеет пустое значение.
 Пути поиска из INCLUDE имеют приоритет над глобальными путями поиска в CMNINCLUDE, эффективный путь для поиска #include-файлов будет состоять из:
 $(INCLUDE) $(CMNINCLUDE) $(SYSINCLUDE)
 Обычно в целевом Makefile пути поиска #include-файлов только дополняются, причём добавленные локальные пути поиска должны иметь приоритет над глобальными путями поиска.
 Если по-умолчанию переменной INCLUDE присвоить значение глобальных путей поиска, то в Makefile пришлось бы писать
 INCLUDE := my_include $(INCLUDE)
 что не удобно.
 Поэтому глобальные пути поиска #include-файлов вынесены в отдельную переменную - CMNINCLUDE.

- SYSINCLUDE - список путей поиска системных #include-файлов (напр. /usr/include).
 Обычно этот список для целевого Makefile формируется через подключение внешних подсистем - через переменную USE.

- SYSLIBPATH - список путей поиска системных библиотек.
 Обычно этот список для целевого Makefile формируется через подключение внешних подсистем - через переменную USE.

- SYSLIBS - системные библиотеки, подключаемые к целевой DLL или EXE.
 Обычно этот список для целевого Makefile формируется через подключение внешних подсистем - через переменную USE.

- USE - подключение подсистем.
 В USE указываются имена подсистем, подключаемых для сборки целевого файла - файлы из $(PROJECT_USE_DIR) (по-умолчанию $(TOP)/make/$(OS)/use).

- DLLS, LIBS, KLIBS - соответственно имена динамических и статических библиотек, необходимых для сборки целевой DLL, EXE или DRV.
 По-умолчанию эти списки пусты, UNIX-систем важен порядок перечисления библиотек.

- CFLAGS, CXXFLAGS, ASMFLAGS, LDFLAGS - соответственно дополнительные флаги С, С++-компиляторов, ассемблера и линкера.
 По-умолчанию эти списки пусты.
 Флаги и опции, используемые при вызове компиляторов целевой платформы, нужно смотреть в соответствующем целевой платформе $(MTOP)/$(OS)/c.mk.

- PCH - имя предкомпилированного заголовочного файла.
 Этот файл подключается первым при компиляции файлов исходных текстов, перечисленных в переменной WITH_PCH.

- WITH_PCH - список файлов исходных текстов, компилируемых с предкомпилённым заголовочным файлом.
 Если под целевой платформой не поддерживается использование предкомпилённых заголовочных файлов, то файлы из списка WITH_PCH компилируются обычным образом - также, как и файлы из списка SRC.

- RPATH - runtime path - пути для поиска динамических библиотек при запуске установленного приложения.
 Переменная RPATH используется только для UNIX-систем, по уолчанию равна $(INST_RPATH).

- MAP - version script - файл с описанием видимости символов (глобальные/локальные) динамической библиотеки.
 Используется только для UNIX-систем, для GNU LD.

- DEF - module definition file - файл с описанием экспортируемых символов динамической библиотеки.
 Используется только для WINDOWS.

- RES - список ресурсных файлов, подключаемых в целевую DLL или EXE.
 Эта переменная используется только для целевой платформы WINDOWS.

2) Создание утилиты.

################################
TOOL_MODE := 1
include $(MTOP)/c.mk
EXE := my_tool
SRC := my_tool_source.c
$(DEFINE_TARGETS)
################################

Здесь присваивается непустое значение переменной TOOL_MODE (которое будет очищено в $(DEFINE_TARGETS)).
Тем самым, следующее включение $(MTOP)/c.mk переопределит пути системы сборки для создаваемых файлов на пути для утилит сборки.
А при создании утилит сборки будет использован компилятор $(TCC) - для исходных текстов на языке C, или $(TCXX) - для исходных текстов на языке C++.
Компилятор утилит $(TCC), используемый в режиме TOOL_MODE может отличаться от компилятора языка C обычного режима $(СС). В этом случае будет выполнена кросс-компиляция - когда собираемые в обычном режиме исполняемые файлы могут не работать на сборочной платформе, в отличие от собираемых в режиме TOOL_MODE утилит сборки.

3) Генерация файлов.

################################
include $(MTOP)/defs.mk
MY_GENERATED := $(GEN_DIR)/my_dir/my_file.txt
$(call ADD_GENERATED,$(MY_GENERATED))
$(MY_GENERATED): MY_OPTIONS := my_options
$(MY_GENERATED): $(call GET_TOOL,my_tool) $(VPREFIX)my_source.txt
	$(call ospath,$<) $(MY_OPTIONS) -o $(call ospath,$(word 2,$^))
$(DEFINE_TARGETS)
################################

включение $(MTOP)/defs.mk добавляет определение стандартных функций и определений, таких как:

GEN_DIR       - путь к директории для сгенерённых файлов (который берёт начало от $(XTOP));
ADD_GENERATED - функция для добавления сгенерённых файлов к сборке - директория $(GET_DIR)/my_dir будет создана автоматически, при выполнении make clean сгенерённые файлы будут удалены;
VPREFIX       - относительный путь от текущей директории до директории, в которой находится целевой Makefile. Таким образом, путь к my_source.txt может быть указан относительно целевого Makefile;
GET_TOOL      - функция получения полного пути к утилите, ранее добавленной в сборку;
ospath        - функция преобразования путей с обратными слешами в пути, специфичные для сборочной платформы (c:/a/b -> c:\a\v\b);

Также в данном Makefile используются:

MY_GENERATED  - произвольно выбранное имя переменной, не обязательно уникальное - система сборки поддерживает режим проверки переопределения зарезервированных имён;
$<            - автоматическая переменная - имя первой зависимости цели, в данном случае это $(call GET_TOOL,my_tool);
$^            - автоматическая переменная - список всех зависимостей цели в порядке их перечисления;
$(word 2,$^)  - имя второй зависимости цели, в данном случае это $(VPREFIX)my_source.txt (замечание: VPREFIX не была объявлена как target-specific переменная, поэтому нельзя использовать выражение $(VPREFIX)my_source.txt в теле правила - VPREFIX может быть изменена после описания правила построения цели но до выполнения этого правила);
MY_OPTIONS    - объявление target-specific переменной - последующие переопределения переменной my_options никак не скажутся на значение этой переменной в правиле генерации $(MY_GENERATED);
$(DEFINE_TARGETS) - стандартный макрос применения шаблонов правил для сборки указанной цели (в данном случае - )

4) Генерация нескольких файлов в одном правиле.

################################
include $(MTOP)/defs.mk
MY_GENERATED := $(addprefix $(GEN_DIR)/my_dir/,my_file1.txt my_file2.txt)
$(call MULTI_TARGET,$(MY_GENERATED),$(call GET_TOOL,my_tool) $(VPREFIX)my_source.txt,$$(call \
  ospath,$$<) $(MY_OPTIONS) -o $(VPREFIX)my_source.txt)
$(DEFINE_TARGETS)
################################

Функция MULTI_TARGET, определённая в $(MTOP)/defs.mk, принимает 3 аргумента:
- список сгенерённых файлов,
- список зависимостей сгенерённых файлов,
- правило генерации файлов.
Так как правило генерации файлов будет раскрыто дважды - первый раз во время вызова MULTI_TARGET, второй - во время выполнения правила, то вызов $(ospath) и переменной $< экранирован двойным $$.
Также, нет необходимости объявлять target-specific переменные - значения MY_OPTIONS и VPREFIX будут раскрыты в момент вызова MULTI_TARGET.

5) Выполняем группу Makefile'ов.

################################
MDEPS := my_gen.mk
TO_MAKE := tool1.mk lib1/my_lib.mk my_exe
include $(MTOP)/parallel.mk
################################

Цели, указанные в Makefile'ах tool1.mk, lib1/my_lib.mk и my_exe/Makefile будут выполнены параллельно с учетом зависимостей между целями.
Присвоенное начение MDEPS указывает на то, что при сборке этого Makefile'а параллельно с my_gen.mk, цели из my_gen.mk должны быть выполнены до выполнения любых целей в tool1.mk, lib1/my_lib.mk и my_exe/Makefile (также и в этих Makefile'ах могут быть указаны зависимости от других Makefile'ов - через переменную MDEPS).
Если данный Makefile выполняется индивидуально, значение MDEPS игнорируется.

6) Собираем что-то уникальное, например выполняем тесты.

################################
include $(MTOP)/defs.mk
MDEPS := build_tests.mk
TESTS := rb_test c_base64_test memstack_test
$(call ADD_GENERATED,$(addprefix $(GEN_DIR)/tests/,$(addsuffix .tsmt,$(TESTS))))
define TEST_RULE
$(newline)
$(GEN_DIR)/tests/$t.tsmt: $(BIN_DIR)/$t$(EXE_SUFFIX)
	$$(call SUP,TEST,$$<)$$< > $(GEN_DIR)/tests/$t.out
	$(if $(VERBOSE),,@)$$(call TOUCH,$$@)
endef
$(eval $(foreach t,$(TESTS),$(TEST_RULE)))
$(DEFINE_TARGETS)
################################

Здесь определяется шаблон TEST_RULE - для построения правил выполнения тестов, подключённых к системе сборки вызовом ADD_GENERATED.

-----------------------------------------------------------------

Более подробно шаблоны построения правил документированы в соответствующих подключаемых файлах - $(MTOP)/defs.mk, $(MTOP)/c.mk и т.д.

Описание некоторых переменных и функций системы сборки.

$(NO_DEPS) - выставляется в непустое значение для отключения авто-генерации зависимостей объектных файлов от заголовочных файлов, подключённых компилируемыми файлами на языке С или С++

переменные - значения символов:
$(empty)   - пустое значение
$(space)   - пробел,
$(tab)     - табуляция,
$(comma)   - запятая,
$(newline) - перевод строки,
$(comment) - символ комментария.

функции:
 unspaces - замена всех пробелов в аргументе на ?,
 ifaddq   - обрамление аргумента двойными кавычками, если аргумент содержит пробелы,
 qpath    - добавление префикса и, если необходимо, то обрамление аргумента двойными кавычками с заменой ? на пробелы в аргументе (эта функция, например, используется для формирования списка путей поиска #include файлов языков C/C++ в системых директориях с пробелами при сборке с использованием MS Visual Studio),
 tolower/toupper - функции преобразования аргумента в нижний/верхний регистр,
 padto    - вычисление длины строки из пробелов для выравнивания текста (используется в кратком выводе вызываемых утилит - если make вызван без V=1),
 xargs    - вызов произвольной функции-обработчика списка, имеющей ограничение на количество элементов в списке (используестся для xcmd),
 xcmd     - вызов утилиты, принимающей на вход ограниченное число агрументов (используется при ограничениях на максимальную длину коммандной строки, например в Windows XP максимальная длина коммандной строки - 8191 символов),
 normp    - нормализация пути - удаление избыточных относительных смен директорий в пути (напр. a/b/../c -> a/c),
 relpath  - вычисление относительного пути от одной директории к другой (напр. $(call relpath,/aa/bb/cc,/aa/dd/qq) -> ../../dd/qq),
 join_with - соединение данным символом всех элементов списка в один элемент.

некоторые обязательные переменные:
$(TARGET) - цель сборки проекта (PROJECTD для DEBUG-сборки, PROJECT для RELEASE-сборки и т.д.),
$(DEBUG)  - значение переменной не пустое в случае отладочной сборки проекта (значение $(TARGET) оканчивается на D),

$(SUPPORTED_OSES)    - список операционных систем, для которых может быть выполнена сборка конкретного проекта,
$(SUPPORTED_CPUS)    - список архитектур процессора, для которых может быть выполнена сборка конкретного проекта,
$(SUPPORTED_TARGETS) - список типов сборок, для которых может быть выполнена сборка конкретного проекта,

$(OS)    - целевая операционная система, под которой будет работать собранный проект и на которой осуществляется сборка проекта,
$(CPU)   - целевая архитектура процессора. Значение этой переменной используется только если не определено значение
 $(UCPU) - целевая архитектура процессора для исполнения в пространстве пользователя,
 $(KCPU) - целевая архитектура процессора для исполнения в пространстве ядра операционной системы,
 $(TCPU) - архитектура процессора, на котором осуществляется сборка проекта;

$(VERBOSE) - значение 1 - включает детальный вывод вызываемых команд сборки целей (VERBOSE выставляется в 1 при запуске make с параметром V=1), значение 0 - отключает детальный вывод вызываемых команд (вместо полной команды выводится мненоника, например CXX file.c),
$(INFOMF)  - внутренняя переменная, выставляется в непустое значение при запуске make с параметром M=1 - для показа имени Makefile'а, в котором было определено правило для выполнения конкретной цели (для отладки сборки во второй фазе - выполнения правил сборки),
$(MDEBUG)  - внутренняя переменная, выставляется в непустое значение при запуске make с параметром D=1 - для показа целей, правила выполнения которых определяет данный Makefile (для отладки сборки в первой фазе - построения правил сборки),
$(MCHECK)  - внутренняя переменная, выставляется в непустое значение при запуске make с параметром C=1 - для проверки корректности Makefile'а до выполнения сборки;

функции:
$(SUP)       - показывает либо детальный вывод вызываемой команды, либо мнемонику команды - в зависимости от значения $(VERBOSE);
$(ospath)    - преобразует аргумент(ы) - пути к файлам и директориям - из UNIX-представления в представление операционной системы $(OS) (напрмер для Windows c:/opt/file -> c:\opt\file),
$(isrelpath) - возвращает не пустое значение если аргумент - относительный путь к файлу.

ЗАМЕЧАНИЕ: в системе сборки предполагается, что пути к целевым файлам и файлам-зависимостям не содержат пробелов.
Обработка путей с пробелами затруднительна, т.к. пробел интерпретируется как разделитель елементов списка (перед обработкой путей с пробелами можно заменить пробел на какой-нибудь символ, например ?, а после обработки - заменить ? обратно на пробел).
