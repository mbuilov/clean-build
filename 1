# clean-build

Простая, быстрая, нерекурсивная, шаблонная, платформонезависимая система сборки, полагающая только на возможности интерпретатора [_Gnu Make_][gmake].

## Содержание

- [Принципы построения](#принципы-построения)
- [Основные характеристики](#основные-характеристики)
- [Установка](#установка)
- [Запуск сборки](#запуск-сборки)
- [Примеры правил](#примеры-правил)

### Принципы построения

- __Декларативное описание сценария сборки__
Для типовых сценариев, в целевом _Makefile_ достаточно указать шаблон и параметры для его инициализации.
Также есть возможность написания произвольных правил сборки, используя возможности [_Gnu Make_][gmake].

- __Нерекурсивность исполнения правил сборки__
Порядок сборки целей определяется только указанием их зависимостей, а не порядком включения целевых _Makefile_'ов (в отличие от рекурсивных систем сборки).
Сначала происходит зачитывание и разбор всех _Makefile_'ов проекта, затем построение единого дерева зависимостей целей, затем (параллельное) выполнение целей.
Единое дерево зависимостей позволяет максимально распараллелить выполнение целей проекта, утилизируя все доступные ресурсы сборочной машины.

- __Использование только нативных утилит сборочной платформы__
Система сборки минималистична, полагается только на возможности [_Gnu Make_][gmake] и, опционально, _sed_ (например [_Gnu Sed_][gsed]).
Данные утилиты доступны в нативном виде для всех поддерживаемых платформ: _Windows_, _Linux_, _Solaris_.

### Основные характеристики
.........

### Установка

Достаточно скопировать [clean-build][cb] в директорию без пробелов в пути, например в `C:\tools` (для _Windows_) или `/usr/home/user` (для _Unix_-like ОС).

### Запуск сборки

Сборка осуществляется обычным вызовом интерпретатора [_Gnu Make_][gmake], примеры:

- `make distclean`

- `make -j4`

- `make -f dir/Makefile check`
или
`make -C dir check`

- вызов из _bash_ (например под _cygwin_) с заданием параметров сборки:
  ```bash
  $ make MTOP=/cygdrive/c/User/clean-build OS=LINUX CPU=x86_64 COMPILER_TYPE=GCC6 NO_STACK_PROTECTOR=1 NO_SANITIZE=1 NO_COVERAGE=1 DLL_PREFIX= DLL_SUFFIX=.dll MEMSTACK_INCLUDE=/cygdrive/c/User/memstack MEMSTACK_LIBDIR='/cygdrive/c/User/memstack/lib/$(TARGET_TRIPLET)' CMN_HEADERS_INCLUDE=/cygdrive/c/User/cmn_headers GTPARSER_INCLUDE=/cygdrive/c/User/gtparser GTPARSER_LIBDIR='/cygdrive/c/User/gtparser/lib/$(TARGET_TRIPLET)'
  ```

- вызов из командного итерпретатора _cmd.exe_ с заданием параметров сборки:
  ```cmd
  C:\User\bitbridge>C:\tools\gnumake-4.2.1-x64.exe MTOP=c:\User\clean-build SED=c:\tools\sed-4.4-x64.exe OS=WINXX CPU=x86 OSVARIANT=WIN7 VS="d:\Program Files (x86)\Microsoft Visual Studio\2017\Community\VC\Tools\MSVC\14.10.25017" WDK="c:\Program Files (x86)\Windows Kits\10" WDK_TARGET="10.0.14393.0" MEMSTACK_INCLUDE=C:\User\memstack MEMSTACK_LIBDIR=C:\User\memstack\lib\$(TARGET_TRIPLET) MEMSTACK_DLLDIR=C:\User\memstack\bin\$(TARGET_TRIPLET) CMN_HEADERS_INCLUDE=C:\User\cmn_headers GTPARSER_INCLUDE=C:\User\gtparser GTPARSER_LIBDIR=C:\User\gtparser\lib\$(TARGET_TRIPLET)
  ```

### Примеры построения правил сборки

- [Сборка статической библиотеки](#сборка-статической-библиотеки)
- [Создание сборочной утилиты](#создание-сборочной-утилиты)
- [Генерация произвольных файлов](#генерация-произвольных-файлов)
- [Генерация нескольких файлов из одного исходного файла](#генерация-нескольких-файлов-из-одного-исходного-файла)
- [Объединение Makefile’ов в группу](#объединение-makefileов-в-группу)
- [Собираем что-то уникальное, например выполняем тесты](#собираем-что-то-уникальное-например-выполняем-тесты)


1) _**Сборка статической библиотеки**_

   ```make
   include $(MTOP)/c.mk
   LIB     := my_lib
   SRC     := my_source1.c my_source2.c
   INCLUDE := my_include1 my_include2
   $(DEFINE_TARGETS)
   ```

   Первой строкой указывается включение файла `$(MTOP)/c.mk` -- добавление шаблонов сборки целей на языках _C_, _C++_.
   Далее указываются параметры шаблонов:
   * `LIB` -- выбирает шаблон сборки статической библиотеки и задаёт её имя (без расширения)
   * `SRC` -- список файлов исходных текстов библиотеки
   * `INCLUDE` -- список дополнительных директорий для поиска _#include_-файлов
   * `$(DEFINE_TARGETS)` -- раскрывает макрос исполнения выбранных шаблонов сборки.


2) _**Создание сборочной утилиты**_

   Сборочная улитита может быть запущена во время сборки, например для генерации исходных текстов.
   В случае кросс-компиляции, архитектура сборочной улититы соответствует архитектуре сборочной машины и может отличаться от архитектуры собираемых исполняемых файлов.

   ```make
   TOOL_MODE := 1
   include $(MTOP)/c.mk
   EXE := my_tool
   SRC := my_tool_source.c
   $(DEFINE_TARGETS)
   ```
   Выставление переменной `TOOL_MODE` в непустое значение (которое будет очищено в `$(DEFINE_TARGETS)`) настраивает шаблоны сборки на создание утилит сборки.
   Тем самым, следующее включение `$(MTOP)/c.mk` переопределит пути системы сборки для создаваемых файлов на пути для утилит сборки.
   Параметры шаблонов:
   * `EXE` -- выбирает шаблон сборки исполняемого файла и задаёт его имя (без расширения)
   * `SRC` -- список файлов исходных текстов исполняемого файла
   * `$(DEFINE_TARGETS)` -- раскрывает макрос исполнения заданных шаблонов сборки.


3) _**Генерация произвольных файлов**_

   Для генерации произвольных файлов нужно определить правила их генерации и добавить сгенерённые файлы в сборку через вызов макроса `ADD_GENERATED`.

   ```make
   include $(MTOP)/defs.mk
   MY_GENERATED := $(GEN_DIR)/my_dir/my_file.txt
   $(call ADD_GENERATED,$(MY_GENERATED))
   $(MY_GENERATED): MY_OPTIONS := my_options
   $(MY_GENERATED): $(call GET_TOOL,my_tool) $(VPREFIX)my_source.txt
       $(call ospath,$<) $(MY_OPTIONS) -o $(call ospath,$(word 2,$^))
   $(DEFINE_TARGETS)
   ```

   Разберём пример построчно.

   1) Включение
      ```make
      $(MTOP)/defs.mk
      ```
      добавляет описание стандартных функций и определений.
      Вообще, включение любого набора шаблонов [clean-build][cb] (например упоминаемый ранее `$(MTOP)/c.mk`) также включает `$(MTOP)/defs.mk`.

   2) Строка
      ```make
      MY_GENERATED := $(GEN_DIR)/my_dir/my_file.txt
      ```
      задаёт имя генерируемого файла.
      Имя переменной `MY_GENERATED` выбрано произвольно, однако возможны коллизии с предопределёнными именами [clean-build][cb].
      Найти коллизии в именах переменных поможет запуск `make C=1` (режим _check makefiles_ -- проверка скриптов сборки одновременно со сборкой).
      `GEN_DIR` -- путь к директории для сгенерённых в процессе сборки файлов.
      Вообще, система сбоки позволяет генерить файлы только в директориях `$(GEN_DIR)`, `$(LIB_DIR)`, `$(BIN_DIR)` или `$(OBJ_DIR)`.

   3) Вызов
      ```make
      $(call ADD_GENERATED,$(MY_GENERATED))
      ```
      добавляет генерируемые файлы в сборку:
      - директория `$(GET_DIR)/my_dir` будет создана автоматически перед вызовом правила генерации файлов
      - при выполнении `make clean` сгенерённые файлы будут удалены

   4) строка
      ```make
      $(MY_GENERATED): MY_OPTIONS := my_options
      ```
      определяет _target-specific_ переменную `MY_OPTIONS` со значением `my_options`.
      В системе сборки [clean-build][cb] важно использовать по-возможности тоько _target-specific_ переменные -- из-за нерекурсивности системы сборки -- после того, как очередной _Makefile_ разобран и определены правила сборки целей, может быть включён и разобран следующий _Makefile_, который может переопределить переменные из первого _Makefile_.
      Поэтому переменные нужно привязывать к цели сборки -- цели сборки всегда уникальны, что контролируется самим [Gnu Make][gmake].

   5) следующие две строки определяют правило сборки файла `$(MY_GENERATED)`
      ```make
      $(MY_GENERATED): $(call GET_TOOL,my_tool) $(VPREFIX)my_source.txt
          $(call ospath,$<) $(MY_OPTIONS) -o $(call ospath,$(word 2,$^))
      ```
      - Первая строка задаёт зависимости `$(MY_GENERATED)` от утилиты сборки и файла `my_source.txt`.
      Раскрытие параметризованного макроса `GET_TOOL` через `$(call GET_TOOL,my_tool)` даёт путь к утилите сборки `my_tool` (пример создания `my_tool` приведён выше).
      Указание `$(VPREFIX)my_source.txt` задаёт зависимость генерируемого файла от `my_source.txt`, расположенного в той же директории, что и _Makefile_.
      В переменной `$(VPREFIX)` содержится относительный путь от директории, в которой запущен _make_ к директории, в которой расположен целевой _Makefile_.

        _Замечание_:
        в приведённых выше примерах сборки статической библиотеки и утилиты переменная `$(VPREFIX)` не указывалась перед именами исходных файлов -- `$(VPREFIX)` добавляется автоматически, если путь не абсолютный (т.е. указан относительно корня проекта `$(TOP)`).
        Здесь же задаётся произвольное правило сборки -- все зависимости нужно указывать явно.

      - Вторая строка (начинающаяся с символа табуляции) определят метод генерации файла.
      `$<` -- автоматическая переменная -- имя первой зависимости цели, в данном случае это путь, возвращаемый `$(call GET_TOOL,my_tool)`.
      Вызовом `$(call ospath,$<)` путь к утилите `my_tool` преобразуется в путь к фалу, характерный для операционной системы сборочной машины (например преобразуется `C:/a/b` -> `C:\a\b`).
      `$(MY_OPTIONS)` -- раскрывается в `my_options`.
      `$^` -- автоматическая переменная -- список всех зависимостей цели в порядке их перечисления.
      `$(word 2,$^)` -- имя второй зависимости цели, в данном случае это `$(VPREFIX)my_source.txt`.

        _Замечание_:
        `VPREFIX` не была объявлена как _target-specific_ переменная, поэтому нельзя использовать выражение `$(VPREFIX)my_source.txt` в теле правила -- `VPREFIX` может быть изменена в следующих _Makefile_'ах, включенных после задания данного правила построения цели.

        `$(call ospath,$(word 2,$^))` -- преобразование пути к `my_source.txt` в путь, характерный для операционной системы сборочной машины.

   6) `$(DEFINE_TARGETS)` -- раскрывает макрос исполнения заданных шаблонов сборки.
      В данном случае, т.к. никаких предопределённых шаблонов сборки указано не было, то `$(DEFINE_TARGETS)` не делает ничего, кроме включения завершающего `$(MTOP)/all.mk`, если текущий _Makefile_ был обработан последним.
      Завершающий `$(MTOP)/all.mk` содержит определение цели по-умолчанию _all_, для выполнения которой нужно выполнить все определённые правила.

      _Замечание_.
      Вместе с заданием правила генерации произвольного файла можно было задать шаблон сборки, скажем библиотеки (включением `$(MTOP)/c.mk` вместо `$(MTOP)/defs.mk`), тогда вызов `$(DEFINE_TARGETS)` также приведёт к сборке библиотеки.


4) _**Генерация нескольких файлов из одного исходного файла**_

   В [_Gnu Make_][gmake] нет специальных средств для решения проблемы с генерацией одним вызовом нескольких файлов из одних и тех же исходных файлов -- правило построения цели в [_Gnu Make_][gmake] предполагает, что целевой файл всегда один.
   А нужно, чтобы правило генерации нескольких целей выполнялось единожды при необходимости обновления любой из целей.

   Для решения этой проблемы, в [clean-build][cb] определён макрос `MULTI_TARGET`.

   ```make
   include $(MTOP)/defs.mk
   MY_OPTIONS := my_options
   MY_GENERATED := $(addprefix $(GEN_DIR)/my_dir/,my_file1.txt my_file2.txt)
   $(call MULTI_TARGET,$(MY_GENERATED),$(call GET_TOOL,my_tool) $(VPREFIX)my_source.txt,$$(call \
    ospath,$$<) $(MY_OPTIONS) -o $(VPREFIX)my_source.txt)
   $(DEFINE_TARGETS)
   ```

   Макрос `MULTI_TARGET`, определённый в `$(MTOP)/defs.mk`, принимает 3 аргумента:
   1) список генерируемых файлов              -- `$(MY_GENERATED)`
   2) список зависимостей генерируемых файлов -- `$(call GET_TOOL,my_tool) $(VPREFIX)my_source.txt`
   3) правило генерации файлов                -- `$$(call ospath,$$<) $(MY_OPTIONS) -o $(VPREFIX)my_source.txt`

   Перед вызовом макроса `MULTI_TARGET`, вычисляется каждый из передаваемых ему аргументов.
   Так как правило генерации файлов, передаваемое 3-им аргументом, будет раскрыто дважды -- первый раз перед вызовом `MULTI_TARGET`, второй -- во время выполнения правила, то обращение к `$(ospath)` и переменной `$<` экранировано двойным `$$`.

   Значение переменной `VPREFIX` необходимо использовать сразу, до включения следующего _Makefile_, в котором `VPREFIX` может быть изменена.
   Или можно сохранить `$(VPREFIX)` в _target-specific_ переменной, чтобы использовать это значение во время выполнения правила.

   Переменная `MY_OPTIONS` не объявлена как _target-specific_, в отличие от предыдущего примера, т.к. используется сразу, в момент определения правила сборки, а не в момент выполнения правила.


5) _**Объединение Makefile'ов в группу**_

   Пример:

   ```make
   MDEPS := my_gen.mk
   TO_MAKE := tool1.mk lib1/my_lib.mk $(TOP)/dir1/dir2/my_exe_dir
   include $(MTOP)/parallel.mk
   ```

   Группа _Makefile_'ов указывается в переменной `TO_MAKE`, значение которой интерпретируется в подключаемом `$(MTOP)/parallel.mk`.

   _Makefile_'ы указываются как имена файлов с расширением _.mk_ или директорий, путь к которым может быть либо относительным от текущего _Makefile_, либо абсолютным - от корня проекта в переменной `$(TOP)`.
   Если элемент списка `$(TO_MAKE)` не заканчивается на _.mk_, то предполагается, что это директория, в которой ищется файл с именем _Makefile_.

   В переменной `MDEPS` можно указать список _Makefile_'ов, от которых зависят цели текущего _Makefile_ (группы _Makefile_'ов, как в данном примере).
   Правила указания _Makefile_'ов в переменной `MDEPS` те же, что и для переменной `TO_MAKE`.

   Цели, указанные в _Makefile_'ах `tool1.mk`, `lib1/my_lib.mk` и `$(TOP)/dir1/dir2/my_exe_dir/Makefile` будут выполнены только после того, как будут выполнены цели _Makefile_'ов из `$(MDEPS)`.

   Если _Makefile_ из `$(MDEPS)` не был подключён к сборке в процессе определения целей, то он игнорируется.
   Таким образом, возможно выполнение (пере-)сборки модуля в его поддиректории, без необходимости пересобирать внешние зависимости, как в следующем примере:

   top_dir/Makefile:
   ```make
   TO_MAKE := gen module
   include $(MTOP)/parallel.mk
   ```

   top_dir/module/Makefile:
   ```make
   MDEPS := ../gen
   ....
   $(DEFINE_TARGETS)
   ```

   Вызов `make clean && make` в директории _top_dir/module_ пересобирёт только цели из этой директории, не трогая цели в _top_dir/gen_.


6) _**Собираем что-то уникальное, например выполняем тесты**_
  
   Пример:

   ```make
   include $(MTOP)/defs.mk
   MDEPS := build_tests.mk
   TESTS := rb_test c_base64_test
   $(call ADD_GENERATED,$(addprefix $(GEN_DIR)/tests/,$(addsuffix .tsmt,$(TESTS))))
   define TEST_RULE
   $(newline)
   $(GEN_DIR)/tests/$t.tsmt: $(BIN_DIR)/$t$(EXE_SUFFIX)
       $$(call SUP,TEST,$$<)$$< > $(GEN_DIR)/tests/$t.out
       $(if $(VERBOSE),,@)$$(call TOUCH,$$@)
   endef
   $(eval $(foreach t,$(TESTS),$(TEST_RULE)))
   $(DEFINE_TARGETS)
   ```

   Здесь:

   1) `MDEPS := build_tests.mk`
   Задаёт что цели, указанные в `build_tests.mk` (например сборка тестируемых исполняемых файлов) должны быть выполнены до целей текущего _Makefile_.

   2) `TESTS := rb_test c_base64_test`
   Список тестируемых исполняемых файлов.

   3) `$(call ADD_GENERATED,$(addprefix $(GEN_DIR)/tests/,$(addsuffix .tsmt,$(TESTS))))`
   В результате запуска тестов будут сгенерены файлы `rb_test.tsmt` и `c_base64_test.tsmt` в директории `$(GEN_DIR)/tests`.

   4) `define TEST_RULE`
    Начало определения шаблона генерации правила запуска теста.

   5) `$(newline)`
   Тело определяемого шаблона `TEST_RULE` начинается со строки, следующей за `define TEST_RULE`.
   Пусть первым символом шаблона будет перевод строки (переменная `newline` определена `в $(MTOP)/defs.mk`).
   Это позволит начинать определение очередного правила с новой строки - при раскрытии шаблона в цикле _foreach_.

   6) шаблонное правило c параметром шаблона `$t`
      ```make
      $(GEN_DIR)/tests/$t.tsmt: $(BIN_DIR)/$t$(EXE_SUFFIX)
          $$(call SUP,TEST,$$<)$$< > $(GEN_DIR)/tests/$t.out
          $(if $(VERBOSE),,@)$$(call TOUCH,$$@)
      ```

      определяет, что результат теста `$t.tsmt` в директории `$(GEN_DIR)/tests` будет зависеть от даты создания тестируемого исполняемого файла `$t$(EXE_SUFFIX)` в директории `$(BIN_DIR)`.

      Для выполнения теста сначала будет вызван исполняемый файл `$(BIN_DIR)/$t$(EXE_SUFFIX)` (указываемый через автоматическую перемсенную `$$<`), а _stdout_ этого вызова будет перенаправлен с помощью `>` в файл `$(GEN_DIR)/tests/$t.out`.
	  Вызов `$$(call SUP,TEST,$$<)` служит для информационной печати на экране выполняемой операции или команды (если _make_ вызван с параметром _V=1_).
      Следующей строка -- вызов`$$(call TOUCH,$$@)` -- вторая команда правила генерации файла `$(GEN_DIR)/tests/$t.tsmt` (указываемого через автоматическую переменную `$$@`).
	  Макрос `TOUCH` определён в `$(MTOP)/defs.mk` через подключение файла определений, специфичного для текущей сборочной платформы.
      Конструкция `$(if $(VERBOSE),,@)` -- даёт пустое значение в _verbose_ режиме (если _make_ вызван с параметром _V=1_) и `@` (директива _make_ -- скрыть выполняемую команду) в обычном режиме.

	  Соответственно, в обычном режиме, при выполнении правила шаблона _make_ напечатает что-то вроде:
	  ```
	  TEST   /home/user/procject/bin/LINUX-x86_64-x86_64-DEBUG/rb_test
	  ```

	  А в _verbose_-режиме:
	  ```
	  /home/user/proj/bin/LINUX-x86_64-x86_64-DEBUG/rb_test > /home/user/proj/gen/LINUX-x86_64-x86_64-DEBUG/rb_test.out
	  touch /home/user/proj/gen/LINUX-x86_64-x86_64-DEBUG/rb_test.tsmt
	  ```

	  _Замечания_:
	  - команды правила должны начинаться с символа табуляции,
	  - тест правил будет интерпретирован дважды, один раз при раскрытии шаблона, второй -- в момент выполнения правил. Поэтому раскрытие некоторых макросов в правилах отложено до второго раза - путём экранирования символа `$` двойным `$$`.

   7) `endef`
   Конец шаблона `TEST_RULE`.
   _Замечание_: тело шаблона не включает перевод строки перед `endef`.

   8) `$(eval $(foreach t,$(TESTS),$(TEST_RULE)))`
   Для каждого `$t` из списка `$(TESTS)` раскрывается шаблон `TEST_RULE`, затем полученный список правил интерпретируется функцией `eval` как если бы эти правила были заданы в тексте _Makefile_.
   
      _Небольшое замечание_:
      функция `foreach` разделяет результаты раскрытия шаблона `TEST_RULE` пробелами, поэтому в конце последней строки шаблона (после `$$(call TOUCH,$$@)`) будет добавлен пробел (добавление которого не играет никакой роли).
      А из-за того, что первым символом шаблона является `$(newline)`, функции `eval` для интерпретации на вход поступят правила, начинающиеся с новой строки.

   9) `$(DEFINE_TARGETS)` -- раскрывает макрос исполнения заданных шаблонов сборки.
   В данном случае, т.к. никаких предопределённых шаблонов сборки указано не было, то `$(DEFINE_TARGETS)` не делает ничего, кроме включения завершающего `$(MTOP)/all.mk`, если текущий _Makefile_ был обработан последним.



   



[gmake]: <https://www.gnu.org/software/make>
[gsed]: <https://www.gnu.org/software/sed>
[cb]: <https://github.com/mbuilov/clean-build>