Описание файлов, необходимых для сборки проектов:

1) make_defs.mk        - файл общих определений, доступных в любом целевом Makefile, включает в себя следующие файлы:
  a) make_top.mk       - проверка корректности значений переменных TOP и XTOP
  b) make_functions.mk - вспомогательные функции и определения
  c) $(TOP)/make/make_features.mk      - файл дополнительных определений проекта (включается, если есть)
  d) $(MTOP)/$(BUILD_OS)/make_tools.mk - описание утилит сборочной платформы (для содания директорий, копирования файлов и т.д.)

2) make_header.mk      - общие шаблоны для сборки целей на языках C или C++, включает в себя следующие файлы:
  a) make_defs.mk      - описан выше
  b) include $(MTOP)/$(OS)/make_header.mk - утилиты и дополнительные шаблоны для сборки целей на языках C или C+

3) make_jheader.mk     - общие шаблоны для сборки целей на языке JAVA, включает в себя следующие файлы:
  a) make_defs.mk      - описан выше
  b) include $(MTOP)/$(OS)/make_jheader.mk - утилиты и дополнительные шаблоны для сборки целей на языке JAVA

4) make_all.mk         - определяет цель сборки по умолчанию (all) и цель очистки результатов сборки (clean)

5) make_parallel.mk    - выполняет "параллельно" список целевых Makefile'ов


Для целевой платформы WINDOWS существует ещё 3 ополнительных файла:

6) $(MTOP)/WINXX/autoconf.mk    - автонастройка системы сборки под WINDOWS
7) $(MTOP)/WINXX/make_stdres.mk - шаблон для создания ресурсного файла с описанием версии продукта
8) $(MTOP)/WINXX/make_wix.mk    - шаблоны для сборки инсталлятора WiX (Windows Installer XML)

-----------------------------------------------------------------

Вспомогательные файлы:

make.bat и make.sh     - автоматическое определение значения переменной TOP - корня проекта.

Определять TOP автоматически бывает удобно в случае наличия нескольких версий проекта.
Если TOP выставляется вручную то, сделав cd в директорию другой версии проекта можно забыть изменить значение TOP и, соответственно, выполнить сборку проекта не из текущей директории.

-----------------------------------------------------------------

Принципы данной нерекурсивной системы сборки.

1) Декларативность во всём.
Порядок выполнения правил сборки целей определяется только их зависимостями, нельзя полагаться на порядок включения целевых Makefile'ов.
(Если нужно задать поядок выполнения целей Makefile'ов, этот порядок нужно указывать явно, например my_dll.mk:my_lib.mk)
Система сборки сначала определяет все правила для выполнения всех целей, затем выполняет эти цели параллельно с учётом зависимостей между целями.

2) Использование target-specific variables (переменных, связанных с целью).
Так как этапы построения правил сборки целей и выполнения этих правил разделены, то нельзя использовать переменные этапа построения правил в самих правилах сборки.
Например, при построении правила сборки библиотеки в переменной LIB задаётся имя собираемой бибиотеки.
После того, как это правило построено, может быть задано построение правила сборки другой библиотеки, с другим значением переменной LIB.
Если использовать переменную LIB при выполнении правила сборки первой библиотеки - LIB уже содержит имя второй библиотеки.
Чтобы запомнить имя библиотеки для его использования при выполнении правила сборки, необходимо задать target-specific переменную.
Значение этой переменной будет связано с целью правила сборки - для разных целей будут разные значения target-specific переменной.
Это позволяет использовать один шаблон для построения правил сборки разных библиокек.

3) Отсутствие правил сборки целей по-образцу (pattern rules).
Вместо этого используются шаблоны построения явных правил сборки.
Во-первых, это проще в отладке - всегда можно определённо сказать, какое правило сборки применяются для данного целевого файла,
во-вторых, достаточно использования Target-specific variables, нет необходимости в Pattern-specific variables.

-----------------------------------------------------------------

Типовые примеры построения правил сборки.

1) Собираем что-то уникальное, например выполняем тесты

include $(MTOP)/make_defs.mk
TESTS   := rb_test c_base64_test memstack_test
$(call ADD_GENERATED,$(addprefix $(BLD_DIR)/tests/,$(addsuffix .tsmt,$(TESTS))))
define TEST_RULE
$(newline)
$(BLD_DIR)/tests/$t.tsmt: $(BIN_DIR)/$t$(EXE_SUFFIX) | $(BLD_DIR)/tests
	$$(call SUPRESS,TEST,$$<)$$< > $(BLD_DIR)/tests/$t.out
	$(if $(VERBOSE:1=),@)$$(call TOUCH,$$@)
CLEAN += $(BLD_DIR)/tests/$t.out
endef
$(eval $(foreach t,$(TESTS),$(TEST_RULE)))
$(DEF_TAIL_CODE)

Разберём построчно что здесь описано.

'include $(MTOP)/make_defs.mk'

включение общих определений из файла $(MTOP)/make_defs.mk:

- проверка значений переменных TOP и XTOP (если XTOP не задан, то XTOP==TOP) - включением $(MTOP)/make_top.mk
- подключение библиотеки макросов - включением $(MTOP)/make_functions.mk
* определяются переменные:
 empty (пустое значение),
 space (пробел),
 tab (табуляция),
 comma (запятая),
 newline (перевод строки)
* и функции
 unspaces - замена всех пробелов в аргументе на ?,
 ifaddq   - обрамление аргумента двойными кавычками, если аргумент содержит пробелы
 qpath    - добавление префикса, обрамление аргумента двойными кавычками и замена ? на пробелы в аргументе (эта функция, например, используется для формирования списка путей поиска #include файлов языка C)
 tolower/toupper - функции преобразования аргумента в нижний/верхний регистр,
 padto    - вычисление длины строки из пробелов для выравнивания текста (используется в кратком выводе вызываемых утилит)
 xargs    - вызов произвольной функции-обработчика списка, имеющей ограничение на количество элементов в списке (используестся для xcmd)
 xcmd     - вызов утилиты, принимающей на вход ограниченное число агрументов (используется при ограничениях на максимальную длину командной строки)
 normp    - нормализация пути - удаление избыточных относительных смен директорий в пути,
 reldir   - вычисление относительного пути от одной директории к другой
 и др.
- определение переменной DEBUG - значение переменной не пустое в случае отладочной сборки проекта,
- подключение опционального настроечного файла проекта, в котором можно определить переменные системы сборки,
- проверка корректности значений переменных
 SUPPORTED_OSES - список поддерживаемых системой сборки конкретного проекта операционных систем,
 SUPPORTED_CPUS - список поддерживаемых системой сборки конкретного проекта архитектур процессора,
 SUPPORTED_TARGETS - список поддерживаемых системой сборки конкретного проекта типов сборок,
 OS       - целевая операционная система, под которой будет работать собранный проект,
 BUILD_OS - операционная система, на которой осуществляется сборка проекта (определяет набор доступных утилит для сборки)
 CPU      - целевая архитектура процессора. Значение этой переменной используется только если не определено значение
  UCPU - целевая архитектура процессора для исполнения в пространстве пользователя,
  KCPU - целевая архитектура процессора для исполнения в пространстве ядра операционной системы,
  TCPU - архитектура процессора, на котором осуществляется сборка проекта.





На данный момент реализованы следующие шаблоны правил.


