Принципы данной нерекурсивной системы сборки.

1) Декларативность.
 Порядок сборки целей определяется только их зависимостями, нельзя полагаться на порядок включения целевых Makefile'ов (в отличие от рекурсивных систем сборки).
 Однако, если нужно задать порядок выполнения Makefile'ов как в рекурсивной системе сборки, зависимость между Makefile'ами нужно указывать явно - через переменную MDEPS.
 Система сборки работает в 2 этапа:
- сначала определяются все правила для выполнения всех целей,
- затем эти правила выполняются параллельно с учётом зависимостей между целями.
 Для удобства, обычно, структура вложенности Makefile'ов соответствует вложенности директорий проекта - при выполнении сборки в какой-либо директории проекта зачитываются все Makefile'ы из этой директории и её под-директорий.

2) Использование target-specific variables (переменных, связанных с целью).
 Так как этапы построения правил сборки целей и выполнения этих правил разделены, то нельзя использовать переменные этапа построения правил в самих правилах сборки.
 Например, при построении правила сборки библиотеки в переменной LIB задаётся имя собираемой библиотеки.
 После того, как это правило построено, может быть задано построение правила сборки другой библиотеки, с другим значением переменной LIB.
 Если использовать переменную LIB при выполнении правила сборки первой библиотеки - LIB уже содержит имя второй библиотеки.
 Чтобы запомнить имя библиотеки для его использования при выполнении правила сборки, необходимо связать переменную LIB с собираемой библиотекой - задать target-specific переменную.
 Значение этой переменной будет связано с целью правила сборки - для разных целей будут разные значения target-specific переменной.
 Это позволяет использовать один и тот же шаблон правил для построения правил сборки разных библиокек.

3) Отсутствие правил сборки целей по-образцу (pattern rules).
 Вместо этого используются шаблоны построения явных правил сборки.
 Во-первых, это проще в отладке - всегда можно определённо сказать, какое правило сборки применяются для данной цели,
 во-вторых, достаточно использования target-specific переменных, нет необходимости в pattern-specific переменных,
 в-третьих, использование pattern-specific переменных может снижать производительность интерпретации Makefile'ов (http://electric-cloud.com/blog/2009/04/makefile-performance-pattern-specific-variables/)

-----------------------------------------------------------------

Описание файлов.

1) defs.mk        - файл общих определений, доступных в любом целевом Makefile, включает в себя следующие файлы:
  a) top.mk       - проверка корректности значений переменных TOP и XTOP
  b) functions.mk - вспомогательные функции и определения
  c) $(TOP)/make/project.mk       - файл дополнительных определений проекта
                                    (включается, если есть - настройки проекта можно задать через переменные окружения)
  d) $(MTOP)/$(BUILD_OS)/tools.mk - утилиты сборочной платформы (содание директорий, копирования файлов и т.д.)

2) c.mk           - общие шаблоны для сборки целей на языках C или C++, включает в себя следующие файлы:
  a) defs.mk      - описан выше
  b) include $(MTOP)/$(OS)/c.mk - утилиты и дополнительные шаблоны для сборки целей на языках C или C++ (компиляторы)

3) java.mk        - общие шаблоны для сборки целей на языках JAVA и SCALA, включает в себя следующие файлы:
  a) defs.mk      - описан выше
  b) include $(MTOP)/$(OS)/java.mk - утилиты и дополнительные шаблоны для сборки целей на языке JAVA

4) all.mk         - определяет цель сборки по умолчанию (all) и цель очистки результатов сборки (clean)

5) parallel.mk    - выполняет "параллельно" список целевых Makefile'ов, служит для обработки списка целевых Makefile'ов


Для целевой платформы WINDOWS существует ещё 3 дополнительных файла:

6) $(MTOP)/WINXX/auto_c.mk - автонастройка системы сборки под WINDOWS
7) $(MTOP)/WINXX/cres.mk   - шаблон для создания ресурсного файла с описанием версии продукта,
                             подключаемого в каждый исполняемый модуль или динамическую библиотеку.
8) $(MTOP)/WINXX/wix.mk    - шаблоны для сборки инсталлятора WiX (Windows Installer XML)

Вспомогательные файлы:

make.bat и make.sh - автоматическое определение значения переменной TOP (корня проекта) - через поиск файла .top в родительских директориях текущей директории.

Определять TOP автоматически бывает удобно в случае наличия нескольких директорий с разными версиями проекта.
Если TOP выставляется вручную то, перейдя в директорию с другой версии проекта можно забыть изменить значение TOP и, соответственно, выполнить сборку проекта не из текущей директории.

-----------------------------------------------------------------

Типовые примеры построения правил сборки.

1) Сборка статической библиотеки.

include $(MTOP)/c.mk
LIB     := my_lib
SRC     := my_source1.c my_source2.c
INCLUDE := my_include1 my_include2
$(DEFINE_TARGETS)

включение $(MTOP)/c.mk добавляет определение шаблонов сборки целей на языках C, C++

LIB     - задаёт имя собираемой библиотеки
SRC     - список файлов исходных текстов библиотеки
INCLUDE - список дополнительных директорий для поиска #include-файлов
$(DEFINE_TARGETS) - стандартный макрос применения шаблонов правил для сборки указанной цели (в данном случае - библиотеки)

Помимо обязательных переменных LIB, SRC и необязательной INCLUDE, можно также задать:

- DEFINES - список #define-определений.
 По-умолчанию, этот список содержит:
  PREDEFINES - список глобальных #define-определений из файла проекта $(TOP)/make/project.mk,
  OS_PREDEFINES - список глобальных #define-определений целевой операционной системы (например _WIN32_WINNT=0x0501).
 Обычно в целевом Makefile список DEFINES дополняется (через DEFINES += my_defs), но можно и исключить глобальные определения из этого списка (через DEFINES := my_defs)

- CMNINCLUDE - глобальный список путей поиска #include-файлов проекта.
 По-умолчанию, этот список равен DEFINCLUDE - списку путей из файла настроек проекта $(TOP)/make/project.mk.
 Чтобы исключить глобальные пути поиска #include-файлов проекта в целевом Makefile нужно очистить CMNINCLUDE присвоив этой переменной пустое значение.

- INCLUDE - список путей поиска #include-файлов.
 Присвоение значения этой переменной в целевом Makefile дополняет пути поиска, по-умолчанию INCLUDE имеет пустое значение.
 Пути поиска из INCLUDE имеют приоритет над глобальными путями поиска в CMNINCLUDE, эффективный путь для поиска #include-файлов будет состоять из:
 $(INCLUDE) $(CMNINCLUDE) $(SYSINCLUDE)
 Обычно в целевом Makefile пути поиска #include-файлов только дополняются, причём добавленные локальные пути поиска должны иметь приоритет над глобальными путями поиска.
 Если по-умолчанию переменной INCLUDE присвоить значение глобальных путей поиска, то в Makefile пришлось бы писать
 INCLUDE := my_include $(INCLUDE)
 что не удобно.
 Поэтому глобальные пути поиска #include-файлов вынесены в отдельную переменную - CMNINCLUDE.

- SYSINCLUDE - список путей поиска системных файлов (напр. /usr/include).
 Обычно этот список для целевого Makefile формируется через подключение внешних подсистем - через переменную USE.

- SYSLIBPATH - список путей поиска системных библиотек.
 Обычно этот список для целевого Makefile формируется через подключение внешних подсистем - через переменную USE.

- SYSLIBS - системных библиотек
 Обычно этот список для целевого Makefile формируется через подключение внешних подсистем - через переменную USE.



 Глобальные пути поиска #include-файлов вынесены в отдельную перенную CMNINCLUDE для удобства

 Поэтому нельзя с переменной INCLUDE поступить аналогично переменной DEFINES.
 Задание дополнительных #define-определений в DEFINES будут переопределять предыдущие из PREDEFINES и OS_PREDEFINES, пути поиска в INCLUDE имеют приоритет над глобальными путями поиска в CMNINCLUDE. Поэтому нельзя 


 В отличие от DEFINES, задание путей поиска 

 Эффективный путь для поиска #include-файлов будет состоять из:
 $(INCLUDE) $(CMNINCLUDE) $(SYSINCLUDE)




1) Собираем что-то уникальное, например выполняем тесты.

include $(MTOP)/defs.mk
TESTS   := rb_test c_base64_test memstack_test
$(call ADD_GENERATED,$(addprefix $(GEN_DIR)/tests/,$(addsuffix .tsmt,$(TESTS))))
define TEST_RULE
$(newline)
$(GEN_DIR)/tests/$t.tsmt: $(BIN_DIR)/$t$(EXE_SUFFIX)
	$$(call SUP,TEST,$$<)$$< > $(GEN_DIR)/tests/$t.out
	$(if $(VERBOSE),,@)$$(call TOUCH,$$@)
endef
$(eval $(foreach t,$(TESTS),$(TEST_RULE)))
$(DEFINE_TARGETS)

Разберём построчно что здесь описано.

'include $(MTOP)/make_defs.mk'

включение общих определений из файла $(MTOP)/make_defs.mk:

- определение переменной NO_DEPS при выполнении цели 'очистки' - для отключения авто-генерации зависимостей целей сборки (например C-файла от заголовочных файлов),
- проверка значений переменных TOP и XTOP (если XTOP не задан, то XTOP==TOP) - включением $(MTOP)/make_top.mk,
- подключение библиотеки макросов - включением $(MTOP)/make_functions.mk, здесь:
* определяются переменные:
 empty (пустое значение),
 space (пробел),
 tab (табуляция),
 comma (запятая),
 newline (перевод строки)
* и функции
 unspaces - замена всех пробелов в аргументе на ?,
 ifaddq   - обрамление аргумента двойными кавычками, если аргумент содержит пробелы,
 qpath    - добавление префикса, обрамление аргумента двойными кавычками и замена ? на пробелы в аргументе (эта функция, например, используется для формирования списка путей поиска #include файлов языка C при сборке с использованием MS Visual Studio),
 tolower/toupper - функции преобразования аргумента в нижний/верхний регистр,
 padto    - вычисление длины строки из пробелов для выравнивания текста (используется в кратком выводе вызываемых утилит - если make вызван без V=1),
 xargs    - вызов произвольной функции-обработчика списка, имеющей ограничение на количество элементов в списке (используестся для xcmd),
 xcmd     - вызов утилиты, принимающей на вход ограниченное число агрументов (используется при ограничениях на максимальную длину коммандной строки, например в Windows XP максимальная длина коммандной строки - 8191 символов),
 normp    - нормализация пути - удаление избыточных относительных смен директорий в пути (напр. a/b/../c -> a/c),
 reldir   - вычисление относительного пути от одной директории к другой (напр. $(call reldir,/aa/bb/cc,/aa/dd/qq) -> ../../dd/qq),
 и др.
- определение переменной DEBUG - значение переменной не пустое в случае отладочной сборки проекта (значение $(TARGET) оканчивается на D),
- подключение опционального настроечного файла проекта ($(TOP)/make/make_features.mk), в котором можно определить переменные системы сборки,
- проверка того, что следующие переменные определены:
 SUPPORTED_OSES    - список операционных систем, для которых может быть выполнена сборка конкретного проекта,
 SUPPORTED_CPUS    - список архитектур процессора, для которых может быть выполнена сборка конкретного проекта,
 SUPPORTED_TARGETS - список типов сборок, для которых может быть выполнена сборка конкретного проекта,
- проверка корректности значений переменных:
 OS       - целевая операционная система, под которой будет работать собранный проект,
 BUILD_OS - операционная система, на которой осуществляется сборка проекта (определяет набор доступных утилит для сборки),
 CPU      - целевая архитектура процессора. Значение этой переменной используется только если не определено значение
  UCPU - целевая архитектура процессора для исполнения в пространстве пользователя,
  KCPU - целевая архитектура процессора для исполнения в пространстве ядра операционной системы,
  TCPU - архитектура процессора, на котором осуществляется сборка проекта;
 TARGET   - тип сборки проекта (DEBUG,RELEASE и т.д.),
- определение переменных:
 VERBOSE - значение 1 - включает детальный вывод вызываемых команд сборки целей (VERBOSE выставляется в 1 при запуске make с параметром V=1), значение 0 - отключает детальный вывод вызываемых команд (вместо полной команды выводится мненоника, например CXX file.c),
 INFOMF  - внутренняя переменная, выставляется в непустое значение при запуске make с параметром M=1 - для показа имени Makefile'а, в котором было определено правило для выполнения конкретной цели (для отладки сборки во второй фазе - выполнения правил сборки),
 MDEBUG  - внутренняя переменная, выставляется в непустое значение при запуске make с параметром D=1 - для показа целей, правила выполнения которых определяет данный Makefile (для отладки сборки в первой фазе - построения правил сборки),
 MCHECK  - внутренняя переменная, выставляется в непустое значение при запуске make с параметром C=1 - для проверки корректности Makefile'а,
- определение функций:
 SUPRESS - показывает либо детальный вывод вызываемой команды, либо мнемонику команды - в зависимости от значения $(VERBOSE),


- определются следующие функции:
 ospath    - преобразует аргумент(ы) - пути к файлам и директориям - из UNIX-представления в представление операционной системы $(BUILD_OS) (напрмер для Windows c:/opt/file -> c:\opt\file),
 isrelpath - возвращает не пустое значение если аргумент - относительный путь к файлу,
ЗАМЕЧАНИЕ: в системе сборки предполагается, что пути к целевым файлам или файлам-зависимостям не содержат пробелов.




На данный момент реализованы следующие шаблоны правил.


